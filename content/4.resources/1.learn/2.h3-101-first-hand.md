---
title: h3 101 - first hand
description: Discover h3, a better API for fetch that works on Node.js, browser, and workers.
authors:
  - name: EstÃ©ban Soubiran
    picture: https://esteban-soubiran.site/esteban.webp
    twitter: soubiran_
packages:
  - h3
publishedAt: 2023-09-12
modifiedAt: 2023-09-12
layout: learn-post
---

<!-- what is h3, the specificity with composable (and tree shaking), perf... -->

## Installation

First, let's create a new project:

```bash
mkdir h3-101
cd h3-101
npm init -y
```

Then, install h3:

```bash
npm install h3
```

::alert{type="info"}
We can use the package manager of our choice like `npm`, `yarn`, `pnpm` or `bun`.
::

## First Server

Before deep diving into [`unjs/h3`](https://github.com/unjs/h3), let's create the simpler server possible to understand how it works and some of its specificities.

To do so, we can create our first file named `first-server.mjs`.

First of all, we will first create our app, where request are processed.

```js [first-server.mjs]
import { createApp } from 'h3'

const app = createApp()
```

Then, we will plug a event handler. It's a function that will be invoked on requests. In our case, we will response to every request with `Hello World!`.

```js [first-server.mjs]
import { createApp, defineEventHandler } from 'h3'

const app = createApp()
  .use('/', defineEventHandler(() => {
    return new Response('Hello World!')
  }))
```

But our app does not listen requests, just handle them for the moment. To listen for requests to be handled, we will use [`node:http`](https://nodejs.org/api/http.html) to create a server and listen on port `3000`.

```js [first-server.mjs]
import { createServer } from 'node:http'
import { createApp, defineEventHandler, toNodeListener } from 'h3'

const app = createApp()
  .use('/', defineEventHandler(() => {
    return new Response('Hello World!')
  }))

createServer(toNodeListener(app)).listen(3000)
```

Finally, we can run it with [`Node.js`](https://nodejs.org/en/):

```bash
node first-script.mjs
```

Then, we can use [`curl`](https://curl.se/) to test it:

```bash
curl http://localhost:3000
# Output: Hello World!
```

And it works!

### Understanding the Code

Let's take a moment to understand the last line because it could be a bit confusing and unfamiliar but it's what's make [`unjs/h3`](https://github.com/unjs/h3) so powerful.

```js
import { createServer } from 'node:http'
import { createApp, toNodeListener } from 'h3'

// ...

createServer(toNodeListener(app)).listen(3000)
```

The fist thing we can notice is that the app is completely runtime agnostic so ready for the future. In fact, we create an app and pass it to a function that wraps it to make it compatible with Node.js. It's called an adapter and the concept is important.

[`unjs/h3`](https://github.com/unjs/h3) provide another important wrapper for the [`Fetch API`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) called `toWebHandler` that get an [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) and return a [`Response](https://developer.mozilla.org/en-US/docs/Web/API/Response). It enable us to deploy [`unjs/h3](https://github.com/unjs/h3) on the edge to [`Cloudflare Workers`](https://workers.cloudflare.com/), [`Deno Deploy`](https://deno.com/deploy), [`Bun`](https://bun.sh/), [`Lagon`](https://lagon.app/), or more.

Secondly, we can notice that we use [`createServer`](https://nodejs.org/api/http.html#httpcreateserveroptions-requestlistener) from `node:http`. The listener is not build-in [`unjs/h3](https://github.com/unjs/h3) because edge runtime don't need it and it's a very platform specific thing.

In the same time, it's allow use to create our own listener to put him on steroids. In the ecosystem, it's called [`unjs/listhen`](https://github.com/unjs/listhen) ðŸ‘‚.

<!-- related article to listhen 101 -->

All of this makes [`unjs/h3](https://github.com/unjs/h3) fully agnostic from the infrastructure and versatile to be used everywhere anytime.

## Add a Router

Now we have understand the basics, let's add a router to our app to make it more useful. In fact, the first example respond always with `Hello World!` but we want to respond with `Hello World!` only on the root path `/`.

We can try with `/foo`:

```bash
curl http://localhost:3000/foo
# Output: Hello World!
```

We expect to have a `404` error but we have a `200` response. It's because we don't have a router and the handler is called on every request.

To fix it, create a new file named `routing.mjs`. Same as before, we will need to create an app and a server.

```js [routing.mjs]
import { createServer } from 'node:http'
import { createApp, toNodeListener } from 'h3'

const app = createApp()

createServer(toNodeListener(app)).listen(3000)
```

Then, we will add a router to our app. It will be able to route requests to the right handler.

```js [routing.mjs]
import { createServer } from 'node:http'
import { createApp, createRouter, defineEventHandler, toNodeListener } from 'h3'

const app = createApp()

const router = createRouter()
  .get('/', defineEventHandler(() => {
    return 'Hello World!'
  }))

app.use(router)

createServer(toNodeListener(app)).listen(3000)
```

When a request is received, the router will try to match it with the right handler. In our case, we have only one handler for the root path `/`.

Finally, we can run it:

```bash
node routing.mjs
```

And test it:

```bash
curl http://localhost:3000
# Output: Hello World!
curl http://localhost:3000/foo
# Output: { "statusCode": 404, "statusMessage": "Cannot find any path matching /foo.", "stack": [] }
```

Perfect! It works as expected.

### HTTP Methods

Let's try `curl -X POST http://localhost:3000` and see what happens.

We receive a `404` error. It's because we setup our handler only for `GET` requests using the `get` method of the router.

To handle others HTTP methods, we can use the appropriate method:

- `router.get` for `GET` requests
- `router.post` for `POST` requests
- `router.put` for `PUT` requests
- `router.patch` for `PATCH` requests
- `router.delete` for `DELETE` requests
- `router.head` for `HEAD` requests
- `router.options` for `OPTIONS` requests
- `router.trace` for `TRACE` requests
- `router.connect` for `CONNECT` requests
- `router.use` for all requests

Perfect! To practice, we can add a new handler for `POST` requests:

```js [routing.mjs]
import { createServer } from 'node:http'
import { createApp, createRouter, defineEventHandler, toNodeListener } from 'h3'

const app = createApp()

const router = createRouter()
  .get('/', defineEventHandler(() => {
    return 'GET: Hello World!'
  }))
  .post('/', defineEventHandler(() => {
    return 'POST: Hello World!'
  }))

app.use(router)

createServer(toNodeListener(app)).listen(3000)
```

We can chain handlers to avoid code duplication (`router.get(...).post(...)`).

::alert{type="info"}
Do not forget to manually restart the server.
::

Then, we can test it:

```bash
curl -X POST http://localhost:3000
# Output: POST: Hello World!
```

Easy! :tada:

## Composables

To interact with the request, [`unjs/h3`](https://github.com/unjs/h3) give us an access to a parameter inside the callback function from `defineEventHandler`.

To illustrate, let's take a little example:

```js
import { createServer } from 'node:http'
import { createApp, defineEventHandler, toNodeListener } from 'h3'

const app = createApp()
  .use('/', defineEventHandler((event) => {
    return 'Hello World!'
  }))
```

Now, we have access to an object called `event` that will be used to get informations from the request and set informations for the response.

The particularity of [`unjs/h3`](https://github.com/unjs/h3) is that we never have to directly interact with this `event` object. Everything is provided as composables and that's we will discover in this section.

### URL Params

Let's start our composables tour with those related to the URL params.

We can create a file named `url-params.mjs` to discover our first composable. Inside, we can create a simple app that will respond with the value of the `id` param.

```js [url-params.mjs]
import { createServer } from 'node:http'
import { createApp, createRouter, defineEventHandler, getRouterParam, toNodeListener } from 'h3'

const app = createApp()

const router = createRouter()
  .get('/:name', defineEventHandler((event) => {
    const name = getRouterParam(event, 'name')

    return `Hello ${name}!`
  }))

app.use(router)

createServer(toNodeListener(app)).listen(3000)
```

The parameter `name` is the name of the parameter in the URL and we could named it as we want. The only important thing is to use the same name in the handler.

::alert{type="info"}
For the majority of composable, we will pass the `event` object as the first parameter. In fact, there is no magic with composables. We can achieve the same result with `event.context.params['name']`. But, don't do it! Sometimes, composables are much more than a simple getter.
::

Then, we can run it:

```bash
node url-params.mjs
```

And test it:

```bash
curl http://localhost:3000/unjs
# Output: Hello unjs
```

Of course, we can have set multiple URL parameters and get all at the same time with `getRouterParams`:

```js [url-params.mjs]
// ...
import { getRouterParams } from 'h3'

const router = createRouter()
  .get('/:name/:age', defineEventHandler((event) => {
    const params = getRouterParams(event)
    // Similar to:
    // const name = getRouterParam(event, 'name')
    // const age = getRouterParam(event, 'age')

    return `Hello ${params.name}! You are ${params.age} years old.`
  }))

// ...
```

Simple, right? And the nice thing is that everything with [`unjs/h3`](https://github.com/unjs/h3) is like this!

### Query Params

Getting is pretty straight forward since there is only one composable `getQuery`.

```js [query-params.mjs]
import { createServer } from 'node:http'
import { createApp, createRouter, defineEventHandler, getQuery, toNodeListener } from 'h3'

const app = createApp()

const router = createRouter()
  .get('/', defineEventHandler((event) => {
    const query = getQuery(event)

    return {
      query
    }
  }))

app.use(router)

createServer(toNodeListener(app)).listen(3000)
```

Then, we can run it:

```bash
node query-params.mjs
```

And test it:

```bash
curl http://localhost:3000?name=unjs
# Output: { "query": { "name": "unjs" } }
```

<!-- Add an alert to say that it's possible to validate query and redirect user to the documentation -->

### Body

Reading the body is also something very simple and we can read it as multiple formats.

```js [body.mjs]
import { createServer } from 'node:http'
import { createApp, createRouter, defineEventHandler, readBody, toNodeListener } from 'h3'

const app = createApp()

const router = createRouter()
  .post('/', defineEventHandler(async (event) => {
    const body = await readBody(event) // Notice that we need to use await because readBody is async

    return {
      body
    }
  }))

app.use(router)

createServer(toNodeListener(app)).listen(3000)
```

Then, we can run it:

```bash
node body.mjs
```

And test it:

```bash
curl -X POST http://localhost:3000 -d '{"name": "unjs"}'
# Output: { "body": { "name": "unjs" } }
```

This works well if the body is `application/json` or `application/x-www-form-urlencoded` or `multipart/form-data`?

To solve this, we have access to more composables:

- `readFormData`, return a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData),
- `readMultipleFormData`, return an array of `MultiPartData` to have access to uploaded files,
- `readRawBody`, return a `Buffer` or a `string`.

### Headers

To interact with `headers`, we have many composables.

Some of them are for the request:
- `getRequestHeader`, get the value of a header from the request using its name,
- `getRequestHeaders`, get all headers from the request as an object,

And others for the response:
- `getResponseHeader`, get the value of a header from the response using its name,
- `getResponseHeaders`, get all headers from the response as an object,
- `setResponseHeader`, set the value of a header from the response using its name,
- `setResponseHeaders`, set all headers from the response using an object.
- `appendResponseHeader`, append the value of a header from the response using its name,
- `appendResponseHeaders`, append all headers from the response using an object.
- `removeResponseHeader`, remove the value of a header from the response using its name,
- `clearResponseHeaders`, clear all headers from the response or those provided as an array.

Let's pratice with all of them!

```js [headers.mjs]
import { createServer } from 'node:http'
import { createApp, createRouter, defineEventHandler, getRequestHeader, getResponseHeader, setResponseHeader, setResponseHeaders, toNodeListener } from 'h3'

const app = createApp()

const router = createRouter()
  .get('/', defineEventHandler((event) => {
    const name = getRequestHeader(event, 'x-name')

    setResponseHeader(event, 'x-server', 'nitro')
    setResponseHeaders(event, { 'x-name': name, 'x-unjs': 'amazing' })

    const unjs = getResponseHeader(event, 'x-unjs')

    return {
      name,
      unjs
    }
  }))

app.use(router)

createServer(toNodeListener(app)).listen(3000)
```

Then, we can run it:

```bash
node headers.mjs
```

And test it:

```bash
curl -v http://localhost:3000 -H 'X-Name: unjs'
# Output: { "headers": { "x-name": "unjs" } }
```

In the same time, we display headers with `-v` and we can observe our `x-server` set to `h3`.

### Status

Handling the status allow us to return correct informations to our client that can be used to provide useful informations to end-user.

To do so, we have access to composables to get and set the status code and message.

First, let's create a file `status.mjs`. Inside, we will set a status with it's message and get it later to return it.

```js [status.mjs]
import { createServer } from 'node:http'
import { createApp, createRouter, defineEventHandler, getResponseStatus, getResponseStatusText, setResponseStatus, toNodeListener } from 'h3'

const app = createApp()

const router = createRouter()
  .get('/404', defineEventHandler((event) => {

    setResponseStatus(event, 404, 'The page you are looking for was not found.') // Message is optional.

    const status = getResponseStatus(event)
    const statusMessage = getResponseStatusText(event)

    return {
      status,
      statusMessage
    }
  }))

app.use(router)

createServer(toNodeListener(app)).listen(3000)
```

Then, we can run it:

```bash
node status.mjs
```

And test it:

```bash
curl -v http://localhost:3000/404
# Output: { "status": 404, "statusMessage": "The page you are looking for was not found." }
```

In the same time, we can observe, thanks to `-v` some headers like `HTTP/1.1 404 The page you are looking for was not found.` which show that everything works fine.

### Redirects

Now we now how to control status, we can also handle some redirects!

For this, we have access to a composable named `sendRedirect` which take the `event` object, a location and optionally, a status code (by default, it's a 301 Permanent Redirect).

To try it, we can create a file named `redirect.mjs` and add a handler that redirect from `/` to `https://unjs.io` using a 302 Found:

```js [redirect.mjs]
import { createServer } from 'node:http'
import { createApp, createRouter, defineEventHandler, sendRedirect, toNodeListener } from 'h3'

const app = createApp()

const router = createRouter()
  .get('/', defineEventHandler((event) => {
    return sendRedirect(event, 'https://unjs.io', 302) // Do not forget to return, it's important.
  }))

app.use(router)

createServer(toNodeListener(app)).listen(3000)
```

Then, we can run it:

```bash
node redirect.mjs
```

And test it:

```bash
curl -v http://localhost:3000
# Output: <!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=https://unjs.io"></head></html>
```

In the same time, we can observe, thanks to `-v` some headers like `location: https://unjs.io` and `HTTP/1.1 302 Found` which show that everything works fine. A redirect must be handled by the client. A browser will automatically follow the redirect and display the page.

### Cookies

[`unjs/h3`](https://github.com/unjs/h3) handle natively cookies. It's a very important feature to build web applications to manage sessions, authentication, and more.

<!-- Add sessions related content by redirecting to future documentation -->

To play with them, we have 3 importants composables:

- `getCookie`, get the value of a cookie from the request using its name,
- `setCookie`, set the value of a cookie from the response using its name,
- `removeCookie`, remove the value of a cookie from the response using its name.

That's it! Let's try it with a file named `cookies.mjs`:

```js [cookies.mjs]
import { createServer } from 'node:http'
import { createApp, createRouter, defineEventHandler, getCookie, removeCookie, setCookie, toNodeListener } from 'h3'

const app = createApp()

const router = createRouter()
  .get('/', defineEventHandler((event) => {
    const name = getCookie(event, 'name')

    setCookie(event, 'server', 'h3', { httpOnly: true, secure: true })
    setCookie(event, 'age', '2', { httpOnly: true, secure: true })
    removeCookie(event, 'age')

    return {
      name
    }
  }))

app.use(router)

createServer(toNodeListener(app)).listen(3000)
```

The `setCookie` composable set `Path` to `/` by default but we can add any options supported by the [Set-Cookie header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).

Then, we can run it:

```bash
node cookies.mjs
```

And test it:

```bash
curl -v http://localhost:3000 -H 'Cookie: name=unjs'
# Output: { "cookies": { "name": "unjs" } }
```

In the same time, we can observe, thanks to `-v` some headers like `Set-Cookie: server=h3; Path=/; HttpOnly; Secure` which show that everything works fine.

### Errors

Finally, we have access to composables to create errors. This can be useful when a user sent wrong data, a validation or a request failed.

To create a new error, there is a composable called `createError`. The simplest way to call it by passing the error message `createError('Something wrong')`.

But you can also pass an object with many options:

- `status`, similar to `statusCode` used to set the HTTP status code for the response,
- `statusText`, similar to `statusMessage` or `message` used to set the HTTP status message for the response,
- `data`, used to provide a custom payload for the log,
- `stack`, used to provide a custom stack for the log,
- `cause`, used to provide a cause for the error,
- `fatal`, used to log the error and stop the execution of the handler.

::alert{type="info"}
Note that `status` have an higher priority than `statusCode` and `statusText` have an higher priority than `statusMessage` or `message`.
::

We can create a little demo for these options:

```js [errors.mjs]
import { createServer } from 'node:http'
import {
  createApp,
  createError,
  createRouter,
  defineEventHandler,
  toNodeListener,
} from 'h3'

const app = createApp()

const router = createRouter()
  .get(
    '/',
    defineEventHandler(() => {
      // Do not forget to return the error
      return createError('A simple error') // Create a 500 Internal Server Error by default
    }),
  )
  .get(
    '/complexe-error',
    defineEventHandler(() => {
      // You can fully customize errors by adding data, cause and if it's a fatal error or not
      return createError({
        status: 400,
        message: 'Bad request',
        statusMessage: 'Bad request message',
      })
    }),
  )
  .get(
    '/fatal-error',
    defineEventHandler(() => {
      // Fatal errors will stop the execution of the current request and will be logged
      return createError({
        status: 500,
        message: 'Fatal error',
        fatal: true,
        data: { foo: 'bar' },
      })
    }),
  )

app.use(router)

createServer(toNodeListener(app)).listen(3000)
```

Then, we can run it:

```bash
node errors.mjs
```

And test it:

```bash
curl -v http://localhost:3000
curl -v http://localhost:3000/complexe-error
curl -v http://localhost:3000/fatal-error
```

And _voilÃ _, we have a nice error handling!

## A Lot More

<!-- redirect to the h3 documentation and talk about hooks, lazy loading, object syntax for event handler, validation... -->
